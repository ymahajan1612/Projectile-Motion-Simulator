import Classes as cls  # importing classes file
import pygame, math  # importing modules
from tkinter import *
from tkinter import messagebox  # importing message box from tkinter
import db_interaction  # importing file for database interaction
import sys
import re  # regex module for pattern matching
import copy

pygame.init()  # initialsing pygame

# Defining colours
white = (255, 255, 255)
green = (0, 255, 0)
maroon = (128, 0, 0)
navy = (65, 67, 118)
orange = (255, 165, 0)
red = (255, 0, 0)
blue = (0, 0, 255)
yellow = (255, 255, 0)
purple = (128, 0, 128)
grey = (128, 128, 128)
black = (0, 0, 0)
sky_blue = (0, 193, 247)

# Defining constants and global variable
G = 9.81  # gravitational field strength
SCREEN_W = 1430  # Screen width
SCREEN_H = 700  # Screen height
SCREEN_CENTRE = (SCREEN_W / 2, SCREEN_H / 2)  # Defining screen centre
large_font = "Impact"
small_font = "arial"
clock = pygame.time.Clock()  # creating pygame clock object
FPS = 60  # Frame rate has been capped to ensure consistency across devices
all_sprites = pygame.sprite.Group()  # a list of all sprites in my program
objects = []  # a list containing all objects
current_user = None  # will later store the current user, necessary for querying database

keys = pygame.key.get_pressed()

# Loading any images required
frame_img = pygame.image.load("rect_frame.png")
title = pygame.image.load("title.png")


def close():  # close function will run when X button pressed
    pygame.quit()
    sys.exit()


def pause(screen, objects_list):  # function that runs when game is pause (esc-key pressed)
    input_component = False
    is_paused = True

    # creating a translucent overlay
    background = pygame.Surface((SCREEN_W, SCREEN_H))
    background.set_alpha(200)
    background.fill(sky_blue)
    screen.blit(background, (0, 0))
    paused_title = cls.Text(500, 10, large_font, 100, 100, white, "Paused", 140)
    paused_title.draw(screen)
    while is_paused:
        pos = pygame.mouse.get_pos()
        for object in objects_list:
            object.draw(screen)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                for object in objects_list:
                    if isinstance(object, cls.Toggle):  # if a toggle is clicked
                        if object.isClicked(pos):  # When toggle false, magnitude + angle input
                            input_component = not input_component
                            object.switch()

            if event.type == pygame.KEYDOWN:  # To leave pause menu
                if event.key == pygame.K_ESCAPE:
                    is_paused = False
        # make return input component
        clock.tick(5)
        pygame.display.update()


def inputs_menu(screen, window, objects_list):  # a function that runs when the ctrl+ i keys pressed
    adjust_inputs = True
    background = pygame.Surface((SCREEN_W, SCREEN_H))
    background.fill(navy)
    screen.blit(background, (0, 0))
    inputs_title = cls.Text(500, 10, large_font, 100, 100, white, "Inputs", 140)

    while adjust_inputs:
        window.update_window(None, background)  # updating the window
        inputs_title.draw(screen)
        pos = pygame.mouse.get_pos()
        for graphic in objects_list:
            if isinstance(graphic, cls.Slider):
                slider_values = cls.Text(graphic.get_dimensions()[0] + graphic.get_dimensions()[2] + 10,
                                         graphic.get_dimensions()[1] - 20, large_font, 100, 100, white,
                                         graphic.get_value(),
                                         70)  # creating text for each slider
                slider_values.draw(screen)

        for graphic in objects_list:
            graphic.draw(screen)  # drawing all objects

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                close()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    adjust_inputs = False

            for graphic in objects_list:
                if isinstance(graphic, cls.Slider):  # Slider is clicked
                    if graphic.slider_square.collidepoint(pos[0], pos[1]):
                        graphic.set_colour(sky_blue)  # changes colour
                        if pygame.mouse.get_pressed()[0]:
                            graphic.update(pygame.mouse.get_pos()[0])  # updates slider square's position
                    else:
                        graphic.set_colour(black)  # Resets colour to black

        clock.tick(30)
        pygame.display.update()


def popup_window(message, title, msg_type="yes/no"):  # a function to display pop-up window -
    window = Tk()
    window.eval("tk::PlaceWindow {} center".format(window.winfo_toplevel()))  # ensures that pop-up is top-most
    window.withdraw()  # removes main window that appears behind pop-up

    if msg_type == "yes/no":
        return messagebox.askyesno(title, message)
    elif msg_type == "retry/cancel":
        return messagebox.askretrycancel(title, message)
    elif msg_type == "info":
        return messagebox.showinfo(title, message)
    elif msg_type == "error":
        return messagebox.showerror(title, message)

    window.deiconify()
    window.destroy()
    window.quit()


def validate(username, password):  # A function to validate user inputs -
    if " " in username:  # checks for space in  username
        return popup_window("Your username should not contain a space", "Error", "error")
    if len(password) < 8:  # length check
        return popup_window("Your password should be longer than 8 characters", "Error", "error")
    elif not re.search("[0-9]", password):  # Checks if password contains at least 1 digit
        return popup_window("Your password should contain at least 1 digit", "Error", "error")
    elif not re.search("[A-Z]", password):  # Checks if password contains at least 1 capital letter
        return popup_window("Your password should contain at least 1 capital letter", "Error", "error")
    return True


# Creating main_screen window
def main_menu():
    main_window = cls.Window(SCREEN_W, SCREEN_H, "Projectile Motion Simulator", "", "background_1.png")
    main_screen = main_window.create_window()
    # Creating buttons on this screen

    # Not added to developement log
    login_button = cls.Button(491, 288, large_font, 118, white, navy, "Login", 452, 116)  # login button
    sign_up_button = cls.Button(491, 424, large_font, 115, white, navy, "Sign-up", 452, 116)
    quit_button = cls.Button(491, 560, large_font, 115, white, navy, "Quit", 452, 116)
    buttons_dict = {login_button: "login", sign_up_button: "sign_up",
                    quit_button: "close"}  # dict of buttons and functions
    # getting list of buttons
    buttons = list(buttons_dict.keys())

    for button in buttons:  # drawing each button
        button.draw(main_screen, True)

    main_screen.blit(title, (58, 29))

    # main loop for main menu
    run_main = True
    while run_main:
        pos = pygame.mouse.get_pos()  # gets mouse position
        for event in pygame.event.get():
            if event.type == pygame.QUIT:  # X button is pressed
                run_main = False
                close()
            if quit_button.isClicked(pos):
                run_main = False
                close()
            if event.type == pygame.MOUSEBUTTONDOWN:
                for button in buttons:
                    if button.isClicked(pos):
                        if button == quit_button:
                            run_main = False
                        eval(buttons_dict.get(button))()  # evaluates string value from dict and runs as function
        pygame.display.update()


def login():  # function for user login -
    global current_user
    global objects
    objects = []
    login_window = cls.Window(SCREEN_W, SCREEN_H, None, None, "background_1.png")
    login_screen = login_window.create_window()

    # setting width and height of textboxes
    box_width = 500
    box_height = 70

    # setting labels for each of the textboxes
    username_label = cls.Text(400, 100, large_font, 100, 100, white, "Username:", 70)
    password_label = cls.Text(400, 300, large_font, 100, 100, white, "Password:", 70)
    login_text = [username_label, password_label]

    # creating two textbox objects and appending them to a list
    username_box = cls.Text_box(SCREEN_CENTRE[0] - box_width / 2, 200, box_width, box_height, str, 60)
    password_box = cls.Text_box(SCREEN_CENTRE[0] - box_width / 2, 400, box_width, box_height, str, 60, True)
    input_boxes = [username_box, password_box]
    objects.append(username_box)
    objects.append(password_box)

    # creating button to login
    login_button = cls.Button(SCREEN_CENTRE[0] - 226, 500, large_font, 115, white, navy, "Login", 452, 116)
    objects.append(login_button)

    run_login = True
    while run_login:
        login_window.update_window()
        login_screen.blit(frame_img, (343, 43))
        pos = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                close()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    main_menu()
            if login_button.isClicked(pos):
                user_details = []  # creates a list to which all user's inputs will be added
                for box in input_boxes:
                    if box.get_text() == "":  # checks if any fields has been left blank
                        if popup_window("You left a field blank, would you like to retry?", "Error", "yes/no"):
                            login()
                        else:
                            main_menu()
                    else:
                        user_details.append(box.get_text())  # appends user's inputs of: username and password
                if db_interaction.login_validation(user_details):  # validates user's input (returns boolean value)
                    popup_window("Login successful", "Success",
                                 "info")  # if True is returned from the login_validation function
                    current_user = user_details[1]  # sets the global variable current user to username
                    mode_menu()  # loads the menu where user selects desired modes
                else:  # if login_validation function returns False/ user's details were incorrect
                    # displaying pop_up
                    if popup_window("Incorrect username or password, would you like to try again?", "Error", "yes/no"):
                        login()  # calling the login function again if user clicks "yes"
                    main_menu()  # calling the main_menu function if user clicks "no"
            for box in input_boxes:  # loops through input boxes
                box.add_chars(event)  # runs the add_chars function to update the inputs
        for text in login_text:
            text.draw(login_screen)
        for object in objects:
            object.draw(login_screen)
        pygame.display.update()


def sign_up():  # sign up function -
    signUp = cls.Window(SCREEN_W, SCREEN_H, "Sign up", None,
                        "background_1.png")
    signUp_screen = signUp.create_window()  # creating sign-up window

    box_width = 500
    box_height = 70

    # creating the textboxes
    name_box = cls.Text_box(SCREEN_CENTRE[0] - box_width / 2, 200, box_width, box_height, str, 60)
    username_box = cls.Text_box(SCREEN_CENTRE[0] - box_width / 2, 325, box_width, box_height, str, 60)
    password_box = cls.Text_box(SCREEN_CENTRE[0] - box_width / 2, 450, box_width, box_height, str, 60, True)
    input_boxes = [name_box, username_box, password_box]

    # sign-up button object
    signUp_button = cls.Button(SCREEN_CENTRE[0] - 226, 540, large_font, 115, white, navy, "Sign-up", 452, 116)

    # labels for each textbox
    name_label = cls.Text(SCREEN_CENTRE[0] - box_width / 2, 145, large_font, 100, 100, white,
                          "Enter your name: ", 50)
    username_label = cls.Text(SCREEN_CENTRE[0] - box_width / 2, 270, large_font, 100, 100, white,
                              "Enter a username:", 50)
    password_label = cls.Text(SCREEN_CENTRE[0] - box_width / 2, 395, large_font, 100, 100, white,
                              "Enter a password:", 50)
    texts = [name_label, username_label, password_label]

    run_signUp = True
    add_user = True  # A boolean to ensure that user is only added once to the database
    while run_signUp:
        signUp.update_window()
        signUp_screen.blit(frame_img, (343, 50))  # displaying the frame to the screen
        signUp_button.draw(signUp_screen, True)
        for text in texts:
            text.draw(signUp_screen)
        pos = pygame.mouse.get_pos()
        for box in input_boxes:
            box.draw(signUp_screen)  # draws each textbox to the screen
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                close()
            for box in input_boxes:
                box.add_chars(event)  # continuously checking for events on each text-box
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    main_menu()
        if signUp_button.isClicked(pos):
            user_details = []  # a list which stores the user's inputs
            for box in input_boxes:
                if box.get_text() == "":  # checking if any textbox is empty
                    # pop-up to notify user of blank field
                    if popup_window("You left a field blank, would you like to retry?", "Error", "retry/cancel"):
                        main_menu()  # if the user clicks cancel on the pop-up box
                    else:
                        sign_up()  # calls the sign_up function if the user clicks retry
                else:  # If no fields are empty
                    user_details.append(box.get_text())  # using the get_text() method to get user's input for each box
            if not validate(user_details[1], user_details[2]):  # if the validate function returns false
                sign_up()
            else:
                while add_user:
                    if db_interaction.signUp_validation(user_details):  # returns True if no other user's found
                        add_user = False  # add user becomes false
                        popup_window("Sign-up successful!", "Success",
                                     "info")  # notifies user that sign-up was successful
                        login()  # goes to login screen
                    else:  # If user enters details of an existing user
                        popup_window("This user already exists, try again", "Error", "error")
                        sign_up()
        pygame.display.update()


def mode_menu():  # A menu where user can select the mode (game/scientific) -
    simulation_menu = cls.Window(SCREEN_W, SCREEN_H, "Select simulation mode", None, "background_1.png").create_window()

    # creating the buttons

    science_button = cls.Button(SCREEN_W / 3, SCREEN_CENTRE[1] - 100, large_font, 75, white, green, "Science mode", 452,
                                116)  # a button that will take the user to science mode
    science_button.draw(simulation_menu, True)

    game_button = cls.Button(SCREEN_W / 3, SCREEN_CENTRE[1] + 40, large_font, 90, white, purple, "Game mode", 452, 116)
    game_button.draw(simulation_menu, True)  # takes the user to game mode

    welcome_message = cls.Text(10, 10, large_font, 100, 100, navy,
                               "Welcome {}!".format(current_user), 100).draw(simulation_menu)
    done = False
    while not done:
        for event in pygame.event.get():
            pos = pygame.mouse.get_pos()
            if event.type == pygame.QUIT:
                pygame.quit()
                close()
            if science_button.isClicked(pos) or game_button.isClicked(pos):  # if either button clicked
                level()  # proceeds to level
        pygame.display.update()


def set_arrow(velocity, angle, projectile):
    x = ((math.cos(math.radians(angle)) * velocity) * 25) + projectile.get_pos()[0]
    y = projectile.get_pos()[1] - ((math.sin(math.radians(angle)) * velocity) * 25)
    return x, y


def launch(sprite_list, launched, landed, screen):
    projectile, floor = sprite_list[0], sprite_list[1]
    if launched and not landed:
        projectile.update_pos()
        # print("Total horizontal distance: ", (projectile.initial_vel_x * projectile.time) / cls.PPM)
    if landed:
        projectile.draw_trail(screen)


"""
def pan_screen(object_list,key): # [projectile,floor,positions, background]
    keys_dict = {pygame.K_UP:5,pygame.K_DOWN:-5,pygame.K_LEFT:5,pygame.K_RIGHT:-5}
    for graphic in object_list:
        if isinstance(graphic,cls.Sprite):
            if key == pygame.K_LEFT or key == pygame.K_RIGHT:
                new_position = (graphic.get_pos()[0] + keys_dict.get(key),graphic.get_pos()[1])
                graphic.set_pos(new_position)
"""


def component_velocities(velocity, angle):
    x_velocity = round(velocity * math.cos(math.radians(angle)), 1)
    y_velocity = round(velocity * math.sin(math.radians(angle)), 1)
    return x_velocity, y_velocity


def level(mode=None):  # mode set None for now, but will be changed depending on what user clicked on mode menu -
    global objects
    global all_sprites
    launched = False
    landed = False
    objects = []  # creates an empty list for all the objects (may create separate list for all texts)
    all_sprites.empty()  # empties the sprite list

    simulation = cls.Window(SCREEN_W, SCREEN_H, "Projectile Simulator", None, None, sky_blue)
    simulation_screen = simulation.create_window()

    # Items for initial inputs menu
    text_pos = SCREEN_W / 2 - 550
    velocity_slider = cls.Slider(text_pos, 270, 30, 0, 15, white, 1000, 40)
    velocity_label = cls.Text(text_pos, 200, large_font, 100, 100, white, "Initial Velocity (m/s)", 60)
    angle_slider = cls.Slider(text_pos, 400, 90, 0, 45, white, 1000, 40)
    angle_label = cls.Text(text_pos, 330, large_font, 100, 100, white, "Angle ({})".format(chr(176)), 60)
    initial_height_slider = cls.Slider(text_pos, 530, 10, 0, 0, white, 1000, 40)
    initial_height_label = cls.Text(text_pos, 460, large_font, 100, 100, white, "Initial Height (m)", 60)
    x_velocity_slider = cls.Slider(text_pos, 270, 10, 0, 5, white, 1000, 40)
    x_vel_label = cls.Text(text_pos, 200, large_font, 100, 100, white, "Horizontal velocity (m/s) ", 60)
    y_velocity_slider = cls.Slider(text_pos, 400, 10, 0, 5, white, 1000, 40)
    y_vel_label = cls.Text(text_pos, 330, large_font, 100, 100, white, "Vertical velocity (m/s) ", 60)

    # Items  for pause menu
    velocity_input_title = cls.Text(SCREEN_CENTRE[0] - 400, 200, large_font, 100, 100, white,
                                    "Select velocity input method: ", 70)
    magnitude_title = cls.Text(50, 300, small_font, 100, 100, white, "Magnitude and Angle", 70)
    components_title = cls.Text(800, 300, small_font, 100, 100, white, "Components", 70)
    velocity_input_switch = cls.Toggle(SCREEN_CENTRE[0] - 100, 300, 150, 75, green, red, False)

    # Items for simulation screen
    launch_button = cls.Button(SCREEN_W / 2 - 125, 585, large_font, 80, white, red, "Launch", 250, 100)

    initial_height_text = cls.Text(10, 90, large_font, 100, 50, white,
                                   "Initial height: {} m".format(initial_height_slider.get_value()), 40)

    initial_velocity_text = cls.Text(10, 10, large_font, 100, 50, white,
                                     "Initial velocity: {} m/s".format(velocity_slider.get_value()), 40)
    x_velocity_text = cls.Text(10, 130, large_font, 100, 50, white, "Horizontal velocity: {} m/s".format(
        component_velocities(velocity_slider.get_value(), angle_slider.get_value())[0]), 40)
    y_velocity_text = cls.Text(10, 170, large_font, 100, 50, white, "Vertical velocity: {} m/s".format(
        component_velocities(velocity_slider.get_value(), angle_slider.get_value())[1]), 40)
    initial_angle_text = cls.Text(10, 50, large_font, 100, 50, white,
                                  "Angle above horizontal: {}{}".format(angle_slider.get_value(), chr(176)), 40)
    velocity_text = cls.Text(10, 10, large_font, 100, 50, white, "Velocity: -", 40)
    magnitude_text = [initial_velocity_text, x_velocity_text, y_velocity_text, initial_angle_text]
    objects = [text for text in magnitude_text]
    objects.extend([launch_button, initial_height_text])

    # creating all sprites and adding to all_sprites list
    floor = cls.Sprite(0, 539, "floor.png")  # floor sprite
    projectile = cls.Projectile(25, 437)  # creating projectile sprite
    velocity_arrow = cls.Sprite(100, 100, "arrow.png")
    velocity_arrow.rect.center = set_arrow(velocity_slider.get_value(), angle_slider.get_value(), projectile)
    velocity_arrow_image = velocity_arrow.get_image()
    velocity_arrow.image = pygame.transform.rotate(velocity_arrow_image, 45)
    all_sprites.add(floor, projectile, velocity_arrow)

    done = False
    while not done:
        simulation.update_window()  # updates window with each iteration
        if not launched:
            pygame.draw.aaline(simulation_screen, black, projectile.rect.center, velocity_arrow.rect.center, 10)
        else:
            all_sprites.remove(velocity_arrow)
        all_sprites.draw(simulation_screen)

        for graphic in objects:
            graphic.draw(simulation_screen)

        for event in pygame.event.get():
            pos = pygame.mouse.get_pos()
            if event.type == pygame.QUIT:
                done = True
                pygame.quit()
                close()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:  # for testing
                    print("Total horizontal distance: ", (projectile.initial_vel_x * projectile.time) / cls.PPM)
                elif event.key == pygame.K_r:  # pressing r resets simulation
                    level()
                elif event.key == pygame.K_ESCAPE:  # pause menu opened
                    objects.clear()
                    objects.extend([velocity_input_title,
                                    magnitude_title,
                                    components_title,
                                    velocity_input_switch
                                    ])
                    pause(simulation_screen, objects)
                    if not velocity_input_switch.get_state():  # if magnitude + angle option selected
                        objects = [text for text in magnitude_text]
                    # if component velocities selected, update velocities
                    else:
                        x_velocity_text = cls.Text(10, 130, large_font, 100, 50, white,
                                                   "Horizontal velocity: {} m/s".format(
                                                       x_velocity_slider.get_value()), 40)
                        y_velocity_text = cls.Text(10, 170, large_font, 100, 50, white,
                                                   "Vertical velocity: {} m/s".format(
                                                       y_velocity_slider.get_value()), 40)
                        try:
                            angle = round(
                                math.degrees(math.atan(y_velocity_slider.get_value() / x_velocity_slider.get_value())),
                                1)
                        except ZeroDivisionError:
                            angle = 90
                        initial_angle_text = cls.Text(10, 50, large_font, 100, 50, white,
                                                      "Angle above horizontal: {}{}".format(angle, chr(176)), 40)
                        total_velocity = round(
                            math.sqrt(x_velocity_slider.get_value() ** 2 + y_velocity_slider.get_value() ** 2),
                            1)  # Vi = sqrt(Vx^2 + Vy^2)
                        initial_velocity_text = cls.Text(10, 10, large_font, 100, 50, white,
                                                         "Initial velocity: {} m/s".format(total_velocity), 40)
                        # A separate list if components option selected
                        components_text = [x_velocity_text, y_velocity_text, initial_angle_text, initial_velocity_text]
                        objects = [text for text in components_text]
                    objects.extend([launch_button, initial_height_text])
                # if CTRL + I is pressed inputs menu opens
                elif event.key == pygame.K_i and (pygame.key.get_mods() & pygame.KMOD_CTRL) and not launched:
                    objects.clear()
                    # appending all required objects to objects list
                    if not velocity_input_switch.get_state():
                        objects.extend([velocity_label,
                                        angle_label,
                                        initial_height_label,
                                        velocity_slider,
                                        angle_slider,
                                        initial_height_slider,
                                        ])
                    else:
                        objects.extend([x_velocity_slider, x_vel_label, y_velocity_slider, y_vel_label,
                                        initial_height_slider, initial_height_label])
                    inputs_menu(simulation_screen, simulation, objects)
                    projectile.set_height(initial_height_slider.get_value())

                    # updating all text
                    initial_height_text.update_text("Initial height: {} m".format(initial_height_slider.get_value()))
                    if not velocity_input_switch.get_state():
                        initial_velocity_text.update_text(
                            "Initial Velocity: {} m/s".format(velocity_slider.get_value()))
                        initial_angle_text.update_text(
                            "Angle above horizontal: {}{}".format(angle_slider.get_value(), chr(176)))
                        x_velocity_text.update_text("Horizontal velocity: {} m/s".format(
                            component_velocities(velocity_slider.get_value(), angle_slider.get_value())[0]))
                        y_velocity_text.update_text("Vertical Velocity: {} m/s".format(
                            component_velocities(velocity_slider.get_value(), angle_slider.get_value())[1]))
                        magnitude_text = [initial_velocity_text, initial_angle_text, x_velocity_text, y_velocity_text]
                        objects = [text for text in magnitude_text]  # adding items to objects list
                    else:
                        x_velocity_text.update_text("Horizontal velocity: {} m/s".format(x_velocity_slider.get_value()))
                        y_velocity_text.update_text("Vertical velocity: {} m/s".format(y_velocity_slider.get_value()))
                        try:
                            angle = round(
                                math.degrees(math.atan(y_velocity_slider.get_value() / x_velocity_slider.get_value())),
                                1)
                        except ZeroDivisionError:
                            angle = 90
                        initial_angle_text.update_text("Angle above horizontal: {}{}".format(angle, chr(176)))
                        total_velocity = round(
                            math.sqrt(x_velocity_slider.get_value() ** 2 + y_velocity_slider.get_value() ** 2),
                            1)  # Vi = sqrt(Vx^2 + Vy^2)
                        initial_velocity_text.update_text("Initial velocity: {} m/s".format(total_velocity))
                        components_text = [x_velocity_text, y_velocity_text, initial_angle_text, initial_velocity_text]
                        objects = [text for text in components_text]

                    objects.extend([initial_height_text, launch_button])
                    # Setting arrow's position and length
                    if not velocity_input_switch.get_state():
                        velocity = velocity_slider.get_value()
                        angle = angle_slider.get_value()
                    else:
                        velocity = math.sqrt(x_velocity_slider.get_value() ** 2 + y_velocity_slider.get_value() ** 2)
                        angle = math.degrees(math.atan2(y_velocity_slider.get_value(), x_velocity_slider.get_value()))

                    velocity_arrow.rect.center = set_arrow(velocity, angle, projectile)
                    velocity_arrow.image = pygame.transform.rotate(velocity_arrow_image, angle)
            # ======================= Code for launching projectile =====================================================
        if launch_button.isClicked(pygame.mouse.get_pos()) and not launched:
            # removing initial text
            objects = [graphic for graphic in objects if
                       graphic not in (initial_velocity_text, initial_height_text, initial_angle_text, x_velocity_text,
                                       y_velocity_text)]
            objects.append(velocity_text)
            launched = True
            if not velocity_input_switch.get_state():
                projectile.set_initialVelocity(velocity_slider.get_value(), angle_slider.get_value())
            else:
                projectile.set_initialVelocity(None, None, x_velocity_slider.get_value(), y_velocity_slider.get_value())

        if launched:
            landed = getattr(projectile, "rect").bottom >= getattr(floor, "rect").top and projectile.get_initial_pos()[
                0] < getattr(projectile, "rect").left and getattr(projectile, "launch_angle") != 90
            # checking for collision between floor and projectile
            if getattr(projectile, "above_ground") and landed:
                projectile.set_height(0)
            if not landed:
                proj_vel = math.sqrt(projectile.initial_vel_x ** 2 + (
                            projectile.initial_vel_y ** 2 + (2 * -G * projectile.get_displacement()))/cls.PPM)
                print(proj_vel)

        launch([projectile, floor], launched, landed, simulation_screen)

        clock.tick(FPS)
        pygame.display.update()


level()